{"version":3,"sources":["components/Header.js","constants.js","components/Cel.js","components/Matrix.js","components/Main.js","components/Footer.js","components/App.js","utils/swipedetect.js","serviceWorker.js","index.js"],"names":["Header","react_default","a","createElement","EmptyCel","value","class","SnakeHead","SnakeBody","Food","SuperFood","Cel","_ref","isOn","celState","className","Matrix","matrix","map","row","rIdx","key","concat","col","cIdx","components_Cel","Main","components_Matrix","Footer","matrixDimensions","height","width","el","callback","swipedir","startX","startY","distX","distY","startTime","handleswipe","document","body","addEventListener","e","touchobj","changedTouches","pageX","pageY","Date","getTime","preventDefault","Math","abs","swipedetect","alert","App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","generateMatrix","rows","cols","toConsumableArray","Array","getFood","state","hasFood","foodPos","_ret","xFood","yFood","snake","maxWidth","maxHeight","hasConflict","floor","random","filter","n","length","setState","v","updateMatrix","isEating","getSnake","food","newMatrix","cel","xCel","yCel","isSnakeBody","xSnake","ySnake","isSnakeHead","isFood","getDirection","keycode","window","event","keyCode","handleKeydown","direction","stop","speed","clearInterval","interval","speedUp","previousState","setInterval","speedDown","_this$state","updatedSnake","splice","snakeHead","unshift","updatedSnakeHeadY","updatedSnakeHeadX","console","log","i","idx","_this2","removeEventListener","handleClick","components_Header","components_Main","components_Footer","Component","Boolean","location","hostname","match","ReactDOM","render","src_components_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7371734b.chunk.js","sourcesContent":["import React from 'react';\n\nconst Header = () => (\n    <header>Header</header>\n)\n\nexport default Header;","export const EmptyCel = {\n    value: 0,\n    class: ''\n};\nexport const SnakeHead = {\n    value: 1,\n    class: 'snakeHead'\n};\nexport const SnakeBody = {\n    value: 2,\n    class: 'snakeBody'\n};\nexport const Food = {\n    value: 3,\n    class: 'snakeFood'\n};\nexport const SuperFood = {\n    value: 4,\n    class: 'snakeSuperFood'\n};","import React from 'react';\nimport {SnakeHead, SnakeBody, Food, SuperFood} from '../constants';\n\nconst Cel = ({isOn, celState}) => {\n    let className = `matrixCel `;\n    if (celState === 1) {\n        className += SnakeHead.class; \n    }\n    if (celState === 2) {\n        className += SnakeBody.class; \n    }\n    if (celState === 3) {\n        className += Food.class; \n    }\n    if (celState === 4) {\n        className += SuperFood.class; \n    }\n    return (\n        <div className={className}></div>\n    )\n}\n\nexport default Cel;","import React from 'react';\nimport Cel from './Cel';\n\nconst Matrix = ({matrix}) => {\n    return (\n        <div className='matrixWrapper'>\n            {matrix.map((row, rIdx) => (<div key={`row-${rIdx}`} className='matrixRow'>\n                {row.map((col, cIdx) => {\n                    return  (\n                        <Cel \n                            key={`col-${cIdx}`}                            \n                            celState={matrix[rIdx][cIdx]}\n                        />\n                    );\n                }\n                )}\n            </div>))}\n        </div>\n    )\n}\n\nexport default Matrix;","import React from 'react';\nimport Matrix from './Matrix';\n\nconst Main = ({matrix}) => (\n    <main>\n        <Matrix \n            matrix={matrix}\n        />\n    </main>\n)\n\nexport default Main;","import React from 'react';\n\nconst Footer = () => (\n    <footer>Footer</footer>\n)\n\nexport default Footer;","import React, { Component } from 'react';\nimport Header from './Header';\nimport Main from './Main';\nimport Footer from './Footer';\nimport './App.css';\nimport {EmptyCel, SnakeHead, SnakeBody, Food} from '../constants';\nimport swipedetect from '../utils/swipedetect';\n\nconst matrixDimensions = {height: 25, width: 25}\n\nvar el = 'oi';\nswipedetect(el, function(swipedir){\n  // swipedir contains either \"none\", \"left\", \"right\", \"top\", or \"down\"\n  if (swipedir =='top') {\n    alert('top swipe');\n  }\n  if (swipedir =='right') {\n    alert('right swipe');\n  }\n  if (swipedir =='down') {\n    alert('down swipe');\n  }\n  if (swipedir =='left') {\n    alert('left swipe');\n  }\n});\n        \n\nclass App extends Component {\n  constructor(props){\n    super(props);\n    this.state = {\n      matrix: this.generateMatrix(matrixDimensions.height,matrixDimensions.width),\n      direction: 'right',\n      speed: 100,\n      snake: [[12,12],[11,12],[10,12]],\n      hasFood: false,\n      foodPos: []\n    }\n  }\n\n  generateMatrix = (rows, cols) => [...new Array(rows)].map(row => [...new Array(cols)].map(col => 0));\n\n  getFood = () => {\n    if (this.state.hasFood) {\n      return this.state.foodPos;\n    } else {\n      const snake = this.state.snake;\n      const maxWidth = matrixDimensions.width;\n      const minWidth = 0;\n      const maxHeight = matrixDimensions.height;\n      const minHeight = 0;\n      let hasConflict = true;\n      let xFood;\n      let yFood;\n      while (hasConflict) {             \n        xFood = Math.floor(Math.random() * (maxWidth - minWidth + 1)) + minWidth;\n        yFood = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;\n        hasConflict = !!snake.filter(n => n[0] === xFood && n[1] === yFood).length;\n      }      \n      this.setState({foodPos: [xFood, yFood], hasFood: true});\n      return [xFood, yFood];\n    }\n  }\n\n  updateMatrix = () => {\n    let snake = this.getSnake(false);\n    let food = this.getFood();\n    let isEating = false;\n\n\n    isEating = snake[0][0] === food[0] && snake[0][1] === food[1];\n\n    if (isEating) {\n      snake = this.getSnake(isEating);\n      this.setState({\n        hasFood: false,\n        foodPos: []\n      })\n    }\n\n    const newMatrix = [...this.state.matrix].map((row, rIdx) => row.map((cel, cIdx) => {\n      const xCel = rIdx;\n      const yCel = cIdx;\n\n      const isSnakeBody = !!snake.filter(n => {\n        const xSnake = n[0];\n        const ySnake = n[1];\n        return xCel === xSnake && yCel === ySnake;\n      }).length;\n\n      const isSnakeHead = xCel === snake[0][0] && yCel === snake[0][1];\n\n      const isFood = xCel === food[0] && yCel === food[1];      \n      \n      return isSnakeBody ? isSnakeHead ? SnakeHead.value : SnakeBody.value : isFood ? Food.value : EmptyCel.value;\n    }));\n  \n    this.setState({matrix: newMatrix})\n  }\n\n  getDirection = e => {\n      const event = window.event ? window.event : e;\n      const keycode = event.keyCode;\n      if (keycode === 38){\n        return 'up';\n      }\n      if (keycode === 40){\n        return 'down';\n      }\n      if (keycode === 37){\n        return 'left';\n      }\n      if (keycode === 39){\n        return 'right';\n      }\n  }\n\n  handleKeydown = event => {\n    this.setState({direction: this.getDirection(event)})\n  }\n\n  componentDidMount() {\n    document.body.addEventListener('keydown', this.handleKeydown);\n    this.interval = setInterval(\n      () => this.updateMatrix(),\n      this.state.speed\n    );\n  }\n\n  \n  stop = () => {\n    this.setState({speed: 0});\n    clearInterval(this.interval);\n  }\n\n  speedUp = () => this.setState((previousState)=>({speed: previousState.speed - 200}), () => {\n    this.interval = setInterval(\n      () => this.updateMatrix(),\n      this.state.speed\n    );\n  });\n\n  speedDown = () => this.setState((previousState)=>({speed: previousState.speed + 200}), () => {\n    this.interval = setInterval(\n      () => this.updateMatrix(),\n      this.state.speed\n    );\n  });\n\n  getSnake = (isEating) => {\n    const { direction, snake } = this.state;\n    const updatedSnake = [...snake];\n    if (!isEating) {\n      updatedSnake.splice(-1,1);\n    }    \n    const snakeHead = snake[0];\n\n    if (direction === 'up') {\n      updatedSnake.unshift([snakeHead[0] - 1,snakeHead[1]]);     \n    }\n\n    if (direction === 'right') {\n      updatedSnake.unshift([snakeHead[0],snakeHead[1] + 1]);\n    }\n\n    if (direction === 'down') {\n      updatedSnake.unshift([snakeHead[0] + 1,snakeHead[1]]);\n    }\n\n    if (direction === 'left') {      \n      updatedSnake.unshift([snakeHead[0],snakeHead[1] - 1]);\n    }\n\n    const updatedSnakeHeadY = updatedSnake[0][0];\n    const updatedSnakeHeadX = updatedSnake[0][1];\n    console.log('updatedSnakeHeadX', updatedSnakeHeadX);\n    console.log(`updatedSnakeHeadX ${updatedSnakeHeadX} matrixDimensions.width ${matrixDimensions.width}`);\n    console.log(`updatedSnakeHeadY ${updatedSnakeHeadY} matrixDimensions.height ${matrixDimensions.height}`);\n    // Game Over if snakeHead leaves bounderies\n    if (updatedSnakeHeadX < 0 || updatedSnakeHeadX >= matrixDimensions.width || updatedSnakeHeadY < 0 || updatedSnakeHeadY >= matrixDimensions.height) {\n      console.log('Game Over - Out of bonderies');\n      this.setState({snake: snake});\n      this.stop();\n      return snake;\n    }\n    // Game Over if sankeHead cross its own body\n    if (updatedSnake.filter((i, idx) => idx > 1 ? updatedSnakeHeadY === i[0] && updatedSnakeHeadX === i[1] : false).length) {\n      console.log('Game Over - Crossing');\n      this.setState({snake: snake});\n      this.stop();\n      return snake;      \n    }\n\n    this.setState({snake: updatedSnake})\n    return updatedSnake;\n  }\n\n  componentWillUnmount() {\n    document.body.removeEventListener('click', this.handleClick);\n    clearInterval(this.interval);\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n       <Header />\n       <Main \n        matrix={this.state.matrix}\n        snake={this.state.snake}\n       />\n       <Footer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const swipedetect = (el, callback) => {\n  \n    let touchsurface = el;\n    let swipedir;\n    let startX;\n    let startY;\n    let distX;\n    let distY;\n    let threshold = 150; //required min distance traveled to be considered swipe\n    let restraint = 100; // maximum distance allowed at the same time in perpendicular direction\n    let allowedTime = 300; // maximum time allowed to travel that distance\n    let elapsedTime;\n    let startTime;\n    const handleswipe = callback || function(swipedir){};\n  \n    document.body.addEventListener('touchstart', function(e){\n        const touchobj = e.changedTouches[0];\n        swipedir = 'none';\n        let dist = 0\n        startX = touchobj.pageX\n        startY = touchobj.pageY\n        startTime = new Date().getTime() // record time when finger first makes contact with surface\n        e.preventDefault()\n    }, false)\n  \n    document.body.addEventListener('touchmove', function(e){\n        e.preventDefault() // prevent scrolling when inside DIV\n    }, false)\n  \n    document.body.addEventListener('touchend', function(e){\n        var touchobj = e.changedTouches[0]\n        distX = touchobj.pageX - startX // get horizontal dist traveled by finger while in contact with surface\n        distY = touchobj.pageY - startY // get vertical dist traveled by finger while in contact with surface\n        elapsedTime = new Date().getTime() - startTime // get time elapsed\n        if (elapsedTime <= allowedTime){ // first condition for awipe met\n            if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint){ // 2nd condition for horizontal swipe met\n                swipedir = (distX < 0)? 'left' : 'right' // if dist traveled is negative, it indicates left swipe\n            }\n            else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint){ // 2nd condition for vertical swipe met\n                swipedir = (distY < 0)? 'up' : 'down' // if dist traveled is negative, it indicates up swipe\n            }\n        }\n        handleswipe(swipedir)\n        e.preventDefault()\n    }, false)\n}\n\nexport default swipedetect;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}